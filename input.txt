МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ “ЛЬВІВСЬКА ПОЛІТЕХНІКА”

 МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ “ЛЬВІВСЬКА ПОЛІТЕХНІКА”



 ЗВІТ
 з проектно-технологічної практики
 на тему
 “ Дослідження та створення архітектурного стилю REST API ”



 Виконав:
 студент групи КІ – 41
 Коваленко Ю.А.
 Перевірив
 Мороз І. В.
 Оцінка:


 Львів – 2020

 ЗМІСТ
 ВСТУП	3
 1.	ТЕОРЕТИЧНІ ВІДОМОСТІ	4
 1.1.	Опис бази практики	4
 1.2.	Основні відомості про REST API	6
 1.3.	Переваги використання REST API.	12
 1.4.	Коли вигідне застосування архітектурного стилю REST API	14
 2.	ПРАКТИНА ЧАСТИНА	15
 2.1.	Технології для створення архітектурного стилю REST API	15
 2.2.	Опис системи та тестування	24
 СПИСОК ВИКОРИСТАНОЇ ЛІТЕРАТУРИ	27


  
 ВСТУП
 REST однин з найпопулярніших архітуктурних підходів
 REST на сьогоднішній день практично витіснив всі інші підходи, в тому числі дизайн заснований на SOAP і WSDL.
 Rеpresentational State Transfer - це архітектура, тобто принципи побудови розподілених гіпермедіа систем, того що іншими словами називається World Wide Web, включаючи універсальні способи обробки і передачі станів ресурсів по HTTP
  
 1.	ТЕОРЕТИЧНІ ВІДОМОСТІ
 1.1.	Опис бази практики
 Базою практики було обрано та одобрено ФОП Олішинського Ярослава Борисовича.
 На базі практики мала змогу отимати досвід з таких галузей як «Комп'ютерне програмування» та «Консультування з питань інформатизації»

 Навчальний проект
 Базою практики було вирішено дати мені змогу отримати практичні навички і навчитись на практиці працювати з одним з найпопулярніших архітектурних підходів таких як REST, використовуючи сучасні та популярні технології.
 Реалізувати REST API на express.js, яка буде імітувати роботу простої моделі “School” із CRUD операціями. Наприклад, повинні бути реалізовані роути на створення, читання (всіх та по ід), редагування та видалення уроку (заняття, лекції, пари тощо), кожен із яких має:
 •	Тему
 •	Вчителя (лектора) (зв’язок з окремою колекцією(таблицею))
 •	Група учнів (студентів) (зв’язок з окремою колекцією(таблицею), студент - також окрема колекція(таблиця))
 •	Кабінет (клас, аудиторію)
 •	Час старту та кінця (або ж порядковий номер уроку/пари із заданого розкладу)

 Основні вимоги до проекту:
 1. робочий бекенд проект
 2. логічно спроектована REST API і база даних
 3. демонстрація роботи з гітом

 Основні інструменти для виконання завдання.
 Під час практики я використвувала:
 •	Ноутбук ASUS
 •	WebStorm – середовище для розробки
 •	Postman – засіб тестування
 •	Google Chrome/DevTools – засоби тестування, запуску та відлагодження.
 •	Git –система контролю версій
 •	SCRUM – методологія робочого процесу

  

 1.2.	Основні відомості про REST API
 REpresentational State Transfer - це архітектура, тобто принципи побудови розподілених гіпермедіа систем, того що іншими словами називається World Wide Web, включаючи універсальні способи обробки і передачі станів ресурсів по HTTP
 Автор ідеї та терміну Рой Філдінг 2000р.
 REST на сьогоднішній день практично витіснив всі інші підходи, в тому числі дизайн заснований на SOAP і WSDL
 Що нам дає REST підхід
 Масштабованості взаємодії компонентів системи (додатки)
 спільність інтерфейсів
 Незалежне впровадження компонентів
 Проміжні компоненти, що знижують затримку, які посилюють безпеку
 	Що таке RESTful:
 Щоб розподілена система вважалася сконструйованої по REST архітектурі (Restful), необхідно, щоб вона задовольняла таким критеріям:
 Client-Server. Система повинна бути розділена на клієнтів і на серверів. Поділ інтерфейсів означає, що, наприклад, клієнти не пов'язані зі зберіганням даних, яке залишається всередині кожного сервера, так що мобільність коду клієнта поліпшується. Сервери не пов'язані з інтерфейсом користувача або станом, так що сервери можуть бути простіше і масштабуються. Сервери та клієнти можуть бути замінні і розроблятися незалежно, поки інтерфейс не змінюється.
 Stateless. Сервер не повинен зберігати будь-якої інформації про клієнтів. У запиті повинна зберігатися вся необхідна інформація для обробки запиту і якщо необхідно, ідентифікації клієнта.
 Cache. Кожна відповідь повинна бути зазначена чи є він кешувального чи ні, для запобігання повторного використання клієнтами застарілих або некоректних даних у відповідь на подальші запити.
 Uniform Interface. Єдиний інтерфейс визначає інтерфейс між клієнтами і серверами. Це спрощує і відокремлює архітектуру, яка дозволяє кожній частині розвиватися самостійно.
 Чотири принципи єдиного інтерфейсу:
 Identification of resources (заснований на ресурсах). У REST ресурсом є все те, чого можна дати ім'я. Наприклад, користувач, зображення, предмет (майка, голодна собака, поточна погода) і т.д. Кожен ресурс в REST повинен бути ідентифікований за допомогою стабільного ідентифікатора, який не змінюється при зміні стану ресурсу. Ідентифікатором в REST є URI.
 Manipulation of resources through representations. (Маніпуляції над ресурсами через подання). Подання в REST використовується для виконання дій над ресурсами. Подання ресурсу являє собою поточний або бажаний стан ресурсу. Наприклад, якщо ресурсом є користувач, то поданням може бути XML або HTML опис цього користувача.
 Self-descriptive messages (само-документовані повідомлення). Під само-описовістю мається на увазі, що запит і відповідь повинні зберігати в собі всю необхідну інформацію для їх обробки. Чи не повинні бути додаткові повідомлення чи кеші для обробки одного запиту. Іншими словами відсутність стану, що зберігається між запитами до ресурсів. Це дуже важливо для масштабування системи.
 HATEOAS (hypermedia as the engine of application state). Статус ресурсу передається через вміст body, параметри рядка запиту, заголовки запитів і запитуваний URI (ім'я ресурсу). Це називається гіпермедіа (або гіперпосилання з гіпертекстом). HATEOAS також означає, що, в разі необхідності посилання можуть містяться в тілі відповіді (або заголовках) для підтримки URI, вилучення самого об'єкта або запитаних об'єктів.
 5 .Layered System. У REST допускається розділити систему на ієрархію шарів але з умовою, що кожен компонент може бачити компоненти тільки безпосередньо наступного шару. Наприклад, якщо ви викликайте службу PayPal а він в свою чергу викликає службу Visa, ви про виробу та техніки безпеки Visa нічого не повинні знати.
 6. Code-On-Demand (опціонально). У REST дозволяється завантаження і виконання коду або програми на стороні клієнта.
 Сервери можуть тимчасово розширювати або кастомизировать функціонал клієнта, передаючи йому логіку, яку він може виконувати. Наприклад, це можуть бути скомпільовані Java-аплети або клієнтські скрипти на Javascript


 Ідемпотентність
 З точки зору RESTful-сервісу, операція (або виклик сервісу) ідемпотентна тоді, коли клієнти можуть робити один і той же виклик неодноразово при одному і тому ж результаті на сервері. Іншими словами, створення великої кількості ідентичних запитів має такий же ефект, як і один запит. Зауважте, що в той час, як ідемпотентна операції виробляють один і той же результат на сервері, відповідь сам по собі може не бути тим же самим (наприклад, стан ресурсу може змінитися між запитами).
 Методи PUT і DELETE за визначенням ідемпотентна. Проте, є один нюанс з методом DELETE. Проблема в тому, що успішний DELETE-запит повертає статус 200 (OK) або 204 (No Content), але для подальших запитів буде весь час повертати 404 (Not Found), Стан на сервері після кожного виклику DELETE те ж саме, але відповіді різні .
 Методи GET, HEAD, OPTIONS і TRACE визначені як безпечні. Це означає, що вони призначені тільки для отримання інформації та не повинні змінювати стан сервера. Вони не повинні мати побічних ефектів, за винятком нешкідливих ефектів, таких як: логирование, кешування, показ банерної реклами або збільшення веб-лічильника.
 За визначенням, безпечні операції ідемпотентна, так як вони призводять до одного і того ж результату на сервері. Безпечні методи реалізовані як операції тільки для читання. Однак безпека не означає, що сервер повинен повертати той же самий результат кожного разу.
 HTTP методи для створення RESTful сервісів
 HTTP метод GET використовується для отримання (або читання) уявлення ресурсу. У разі "вдалого" (або не містять помилок) адреси, GET повертається уявлення ресурсу у форматі XML або JSON в поєднанні з кодом стану HTTP 200 (OK). У разі наявності помилок зазвичай повертається код 404 (NOT FOUND) або 400 (BAD REQUEST).
 GET http://www.example.com/api/v1.0/users (повернути список користувачів)
 GET http://www.example.com/api/v1.0/users/12345 (повернути дані про користувача з id 12345)
 GET http://www.example.com/api/v1.0/users/12345/orders
 HTTP метод PUT зазвичай використовується для надання можливості поновлення ресурсу. Тіло запиту при відправленні PUT-запиту до існуючого ресурсу URI має містити оновлені дані оригінального ресурсу (повністю, або тільки оновлювану частина).
 Для створення нових екземплярів ресурсу переважніше використання POST запиту. В даному випадку, при створенні екземпляра буде надано коректний ідентифікатор екземпляра ресурсу в повернутих даних про екземпляр.
 При успішному оновленні за допомогою виконання PUT запиту повертається код 200 (або 204 якщо не був переданий будь-якої контент в тілі відповіді). PUT небезпечно операція, так як внаслідок її виконання відбувається модифікація (або створення) примірників ресурсу на стороні сервера, але цей метод ідемпотентів. Іншими словами, створення або оновлення ресурсу за допомогою відправки PUT запиту - ресурс не зникне, буде розташовуватися там же, де і був при першому зверненні, а також, багаторазове виконання одного і того ж PUT запиту не змінить загального стану системи
 PUT http://www.example.com/api/v1.0/users/12345 (оновити дані користувача з id 12345)
 PUT http://www.example.com/api/v1.0/users/12345/orders/98765 (оновити дані замовлення з id 98765 для користувача з id 12345)
 HTTP метод POST запит найбільш часто використовується для створення нових ресурсів. На практиці він використовується для створення вкладених ресурсів. Іншими словами, при створенні нового ресурсу, POST запит відправляється до батьківського ресурсу і, таким чином, сервіс бере на себе відповідальність на встановлення зв'язку створюваного ресурсу з батьківським ресурсом, призначення нового ресурсу ID і т.п.
 При успішному створенні ресурсу повертається HTTP код 201, а також в заголовку `Location` передається адреса створеного ресурсу.
 POST не є безпечним або ідемпотентна запитом. Тому рекомендується його використання для НЕ ідемпотентна запитів. В результаті виконання ідентичних POST запитів надаються сильно схожі, але не ідентичні дані.
 POST http://www.example.com/api/v1.0/customers (створити новий ресурс в розділі customers)
 POST http://www.example.com/api/v1.0/customers/12345/orders (створити замовлення для ресурсу з id 12345)
 HTTP метод DELETE використовується для видалення ресурсу, ідентифікованого конкретним URI (ID).
 При успішному видаленні повертається 200 (OK) код HTTP, спільно з тілом відповіді, що містить дані віддаленого ресурсу. Також можливе використання HTTP коду 204 (NO CONTENT) без тіла відповіді. Згідно зі специфікацією HTTP, DELETE запит ідемпотентів. Якщо ви виконуєте DELETE запит до ресурсу, він видаляється. Повторний DELETE запит до ресурсу закінчиться також: ресурс видалений. Якщо DELETE запит використовується для декремента лічильника, DELETE запит не є ідемпотентна. Використовуйте POST для НЕ ідемпотентна операцій.
 Проте, існує застереження про ідемпотентності DELETE. Повторний DELETE запит до ресурсу часто супроводжується 404 (NOT FOUND) кодом HTTP через те, що ресурс вже видалений (наприклад з бази даних) і більш не доступний. Це робить DELETE операція не Ідемпотентний, але це загальноприйнятий компроміс на той випадок, якщо ресурс був вилучений з бази даних, а не позначений, як віддалений.
 DELETE http://www.example.com/api/v1.0/customers/12345 (видалити з customers ресурс з id 12345)
 DELETE http://www.example.com/api/v1.0/customers/12345/orders/21 (видалити у ресурсу з id 12345 замовлення з id 21)
 Коди станів HTTP
 Основні групи кодів станів: (link)

 1xx: Information
 100: Continue
 2xx: Success
 200: OK
 201: Created
 202: Accepted
 204: No Content
 3xx: Redirect
 301: Moved Permanently
 307: Temporary Redirect
 4xx: Client Error
 400: Bad Request
 401: Unauthorized
 403: Forbidden
 404: Not Found
 5xx: Server Error
 500: Internal Server Error
 501: Not Implemented
 502: Bad Gateway
 503: Service Unavailable
 504: Gateway Timeout


 1.3.	Переваги використання REST API.
 Переваги REST:
 Відсутність додаткових внутрішніх прошарків, що означає передачу даних в тому ж вигляді, що і самі дані. Тобто дані не обертаються в XML, як це робить SOAP і XML-RPC, не використовується AMF, як це робить Flash і т.д. Просто віддаються самі дані.
 Кожна одиниця інформації (ресурс) однозначно визначається URL - це значить, що URL по суті є первинним ключем для одиниці даних. Причому абсолютно не має значення, в якому форматі знаходяться дані за адресою - це може бути і HTML, і jpeg, і документ Microsoft Word.
 Як відбувається управління інформацією ресурсу - це цілком і повністю ґрунтується на протоколі передачі даних. Найбільш поширений протокол звичайно ж HTTP. Для HTTP дію над даними задається за допомогою методів: GET (отримати), PUT (додати, замінити), POST (додати, змінити, видалити), DELETE (видалити). Таким чином, дії CRUD (Create-Read-Update-Delete) можуть виконуватися як з усіма 4-ма методами, так і тільки за допомогою GET і POST.

  
 1.4.	Коли вигідне застосування архітектурного стилю REST API
 Коли використовувати REST?
 • Коли є обмеження пропускної здатності з'єднання
 • Якщо необхідно кешувати запити
 • Якщо система передбачає значне масштабування
 • У сервісах, що використовують AJAX
  
 2.	ПРАКТИНА ЧАСТИНА
 2.1.	Технології для створення архітектурного стилю REST API
 Як відомо мова програмування всього лиш інструмент, тому щоб написати повноцінний REST API можна вибрати будь яку технологію для так званого роутингу. Однак варто зазначити, що кожна з цих технологій вибирається відповідно до певних вимог, таких як об’єм проекту, його вартість, складність операцій, і тд.
 Найпопулярніші з них:
 1.	Java/Spring
 2.	.NET\C#
 3.	Node.js/Express
 4.	Python
 Важливо також не забути про бази даних, адже навіть наймінімальніший сервіс використвоє їх. Існує як SQL так і NoSQL бази даних і кожна з них вибирається відповідно до технології і мови програмування, а також відповідно до вимог які та об’єму даних, які буде використовувати сервіс.
 Найпопулярніші БД:
 1.	MySQL
 2.	PostgreSQL
 3.	MongoDB
 4.	Redis
 Крім БД також часто застосовуються ORM бібліотеки для спрощення операцій доступу до БД.(Sequelize, Mongoose, та інші)
 Також важливою складовою є саме захист даних від зловмисників, одними з найпопулярніших способів є використання JWT-auth, Passport.js, bcrypt.js.
 Розробка REST API
 1.
 Цей набір інструментів, необхідних для побудови REST API. Ці інструменти не залежать від платформи, а це означає, що вони застосовні до REST API, побудованих з будь-яким стеком технологій.
 Детальний виклад цих інструментів можна знайти в Інтернеті. Різні етапи розробки API перелічені нижче.
 Дизайн - Основною метою тут є визначення форми API, інтерфейсів документів та надання кінцевих точок заглушки.
 Тестування -  Тут ми виконуємо функціональне тестування API, надсилаючи запит та аналізуючи відповідь на різних рівнях видимості, а саме: додаток, HTTP та мережа.
 Веб-хостинг -  при розгортанні в Інтернеті існують HTTP-інструменти, які допомагають розміщувати API для продуктивності, безпеки та надійності.
 Продуктивність -  Перш ніж переходити до виробництва, ми використовуємо інструменти для тестування продуктивності API, які повідомляють нам, скільки навантажень можуть підтримувати API.
 Спостережливість -  Після того, як API розгорнуто у виробництві, тестування у виробництві забезпечує загальний стан активних API та попереджає нас, якщо виникає проблема.
 Управління -  нарешті, ми розглянемо деякі інструменти для діяльності з управління API, такі як формування трафіку, синьо-зелене розгортання, канарейка тощо.
 На наступному малюнку показано різні етапи висвітлення інструментів.
 Дизайн
 На етапі проектування розробник API співпрацює з клієнтами API та постачальником даних, щоб отримати форму API. REST API по суті складається з обміну повідомленнями JSON через HTTP. JSON є домінуючим форматом в REST API, оскільки він компактний, простий у розумінні та має гнучкий формат, який не вимагає попереднього декларування схеми. Різні клієнти можуть використовувати один і той же API і читати потрібні їм дані.
 Swagger- це інструмент, який використовує відкритий формат для опису API у поєднанні з веб-інтерфейсом для візуалізації та спільного використання. Не існує поділу між дизайном та реалізацією. Це інструмент документації API, де документація розміщується поряд з API. Перевага цього полягає в тому, що API та документація також залишатимуться синхронізованими. Недоліком є те, що лише розробники API можуть змінювати структуру API. Документація формується з API. Це означає, що нам потрібно спочатку побудувати скелет нашого API. Ми використали Spring Boot для розробки API та пакету Springfox для створення документації про перевід.
 Тестування
 Функціональне тестування API REST передбачає надсилання запитів HTTP та перевірку відповідей, щоб ми могли перевірити, чи працюють API, як ми очікуємо. REST використовує HTTP для транспортування, що визначає формати запитів та відповідей API. TCP / IP, у свою чергу, приймає повідомлення HTTP і вирішує, як їх транспортувати по дроту.
 Postman - це клієнт REST, який дозволяє нам тестувати API REST. Це дозволяє нам:
 Створювати HTTP-запити та генерувати еквівалентні команди cURL, які можна використовувати у сценаріях.
 Створювати кілька середовищ для Dev, Test, Pre-Prod, оскільки кожне середовище має різні конфігурації.
 Створювати колекцію тестів, що містить кілька тестів для кожної галузі продукту. Різні частини тесту можна параметризувати, що дозволяє нам перемикатися між середовищами.
 Створювати фрагменти коду в JavaScript, щоб збільшити наші тести, наприклад, затвердити коди повернення або встановити змінні середовища.
 Автоматизовувати запуск тестів за допомогою інструменту командного рядка під назвою Newman.
 Веб хостинг
 Розглянемо деякі функції протоколу HTTP, які при правильному використанні допомагають нам забезпечити ефективні, високодоступні, надійні та безпечні API. Зокрема, ми розглянемо три частини протоколу HTTP - кешування для продуктивності, DNS для високої доступності та масштабованості та TLS для транспортної безпеки.
 Кешування -  кешування - це один із найкращих способів поліпшити роботу клієнта та зменшити навантаження на API. HTTP дозволяє клієнтам зберігати копію ресурсу локально, надсилаючи у відповідь заголовок кешування. Наступного разу клієнт надсилає HTTP-запит на той самий ресурс, він буде обслуговуватися з локального кешу. Це економить як мережевий трафік, так і обчислювальне навантаження на API.
 HTTP 1.0 Кешування закінчення терміну дії . HTTP 1.0 забезпечує Expiresзаголовок у відповіді HTTP із зазначенням часу, коли ресурс закінчується. Це може бути корисно для спільного ресурсу з фіксованим часом закінчення.
 HTTP 1.1 Кешування закінчення терміну дії . HTTP 1.1 забезпечує більш гнучкий заголовок закінчення терміну дії, cache-controlякий вказує клієнту кешувати ресурс протягом періоду, який встановлений у max-ageзначенні. Існує ще одне значення, s-maxageяке можна встановити для посередників, наприклад, кеш-проксі.
 Кешування HTTP-перевірки . При кешуванні виникає проблема, коли клієнт має застарілий ресурс або два клієнти мають різні версії одного ресурсу. Якщо це неприйнятно або якщо є персоналізовані ресурси, які неможливо кешувати, наприклад, маркери автентифікації, HTTP забезпечує кешування перевірки. За допомогою кешування перевірки HTTP надає заголовки у відповіді Etagабо last-modifiedмітці часу. Якщо API повертає будь-який із двох заголовків, клієнти кешують його та включають у наступні виклики GET до API.
 Якщо ресурс не змінено, API поверне 304 Not Modifiedвідповідь без тіла, і клієнт може безпечно використовувати його кешовану копію.
 DNS -  Система доменних імен знаходить IP-адреси для доменного імені, щоб клієнти могли направити свій запит на правильний сервер. Коли HTTP-запит зроблений, клієнти спочатку запитують DNS-сервер, щоб знайти адресу для хоста, а потім відправляють запит безпосередньо на IP-адресу. DNS - це багаторівнева система, яка сильно кешована, щоб гарантувати, що запити не сповільнюються. Клієнти підтримують DNS-кеш, тоді є проміжні DNS-сервери, що ведуть аж до сервера імен. DNS забезпечує CNAME (Canonical Names) для доступу до різних частин сервера, наприклад, і API, і веб-сервер можуть розміщуватися на одному сервері з двома різними CNAME - api.endpoint.comіwww.endpoint.comабо CNAME можуть вказувати на різні сервери. CNAME також дозволяють нам відокремлювати частини нашого API. Для HTTP-запитів GET ми можемо мати окремий CNAME для статичних та транзакційних ресурсів, що дозволяє нам встановити проксі-сервер для ресурсів, які, як ми знаємо, можуть бути зверненнями в кеш. Ми також можемо мати CNAME для запитів HTTP POST для розділення читання та запису, щоб ми могли масштабувати їх самостійно. Або ми можемо забезпечити швидкісний шлях для пріоритетних клієнтів.
 З розширеними DNS, такими як Route53, один CNAME замість того, щоб просто вказувати на один сервер, може вказувати на кілька серверів. Потім політика маршрутизації може бути налаштована на зважену маршрутизацію, маршрутизацію із затримкою або на відмовостійкість.

 TLS -  Ми можемо захистити наші API за допомогою TLS, що дозволяє нам обслуговувати наш запит через HTTPS. HTTPS працює за основним принципом безпеки пари ключів. Щоб увімкнути HTTPS на нашому API, нам потрібен сертифікат на нашому сервері, який містить відкриту та приватну пару ключів. Сервер надсилає відкритий ключ клієнту, який використовує його для шифрування даних, а сервер використовує свій приватний ключ для їх розшифровки. Коли клієнт вперше підключається до кінцевої точки HTTPS, відбувається рукостискання, коли клієнт і сервер домовляються про те, як шифрувати трафік. Вони обмінюються ще одним унікальним для сеансу ключем, який використовується для шифрування та дешифрування даних протягом усього сеансу. Під час початкового рукостискання відбувається атрибут продуктивності через асиметричне шифрування, але після встановлення зв’язку використовується симетричне шифрування, яке відбувається досить швидко.
 Для проксі-серверів для кешування трафіку TLS нам потрібно завантажити той самий сертифікат, який використовується для шифрування трафіку. Проксі повинен мати можливість розшифрувати трафік, зберегти його в кеш-пам’яті та зашифрувати тим самим сертифікатом і надіслати клієнту. Деякі проксі-сервери цього не дозволяють. У таких ситуаціях одним із рішень є наявність двох CNAME - один для статичних кешуваних ресурсів через HTTP та для персоналізованих ресурсів, що не кешуються, запити через захищений канал TLS будуть обслуговуватися API безпосередньо.
 Продуктивність
 Розглянемо інструменти для тестування нашого API, щоб ми могли кількісно визначити, з яким обсягом трафіку може впоратися наша інфраструктура. Основна ідея тестування продуктивності полягає в тому, щоб одночасно надсилати до API багато запитів і бачити, в який момент продуктивність погіршується і в кінцевому підсумку не вдається. Відповіді, які ми шукаємо, такі:
 Який час відгуку може дати API за різних умов навантаження?
 Скільки одночасних запитів API може обробляти без помилок?
 Яка інфраструктура потрібна для досягнення бажаної продуктивності?
 loader.io - це хмарна послуга безкоштовного тестування навантаження, яка дозволяє стрес-тестувати наші API. Для отримання базової продуктивності API можна проводити різні види навантажувальних тестів із збільшенням навантажень, що вимірюється кількістю запитів в секунду, щоб дізнатися показники продуктивності, кількісно виражені помилками та часом відгуку, для
 Тест на замочування -  середнє навантаження протягом тривалих періодів, наприклад, біг протягом 48 годин при 1 запиті в секунду. Це дозволить виявити будь-які витоки пам’яті чи інші подібні приховані помилки.
 Тест навантаження -  пікове навантаження, наприклад, виконуйте 2K запити в секунду за допомогою 6 екземплярів API.
 Стрес-тест -  перевищення пікового навантаження, наприклад, 10 000 запитів в секунду протягом 10 хвилин.
 Це також дозволяє нам визначитись з інфраструктурою, яка дозволить нам поставляти API із бажаними показниками продуктивності та чи масштабується наше рішення лінійно.
 Спостережливість
 Як тільки API розгортається у виробництві, це не означає, що ми можемо забути про API. Розгортання виробництва розпочинає черговий етап тестування - тестування у виробництві, яке може виявити проблеми, які залишались невловимими на попередніх етапах. Випробування на виробництві включають комплекс заходів, об'єднаних як спостережливість, що включає реєстрацію, моніторинг та відстеження. Інструменти для цієї діяльності допоможуть нам діагностувати та вирішувати проблеми, виявлені у виробництві.
 Протоколювання -  реєстрація повинна виконуватися розробниками явно, використовуючи бажану структуру ведення журналу та стандарт ведення журналу. Наприклад, один оператор журналу на кожні 10 рядків коду або більше, якщо код складний з рівнями журналу, розділеними на - 60 відсотків DEBUG, 25 відсотків INFO, 10 відсотків ПОПЕРЕДЖЕННЯ і 5 відсотків ПОМИЛКИ.
 Моніторинг -  Моніторинг працює на вищому рівні, ніж реєстрація. Хоча реєстрація явно повідомляє нам, що відбувається з API, моніторинг забезпечує загальний стан роботи API, використовуючи загальні показники, виставлені платформою та самим API. Зазвичай показники виставляються агентом, розгорнутим на сервері, або він може бути частиною рішення, і періодично збирається рішенням моніторингу, розгорнутим віддалено.
 Діагностичні кінцеві точки можуть бути включені в рішення, яке повідомляє нам про загальний стан роботи API.
 Zipkin - це розподілена система трасування. Це допомагає зібрати дані про терміни, необхідні для усунення проблем із затримками в архітектурі мікросервісу.
 Увімкнення централізованого журналювання охоплює ведення журналу та трасування. Для моніторингу цікаві показники можуть зберігатися в магазині часових рядів, таких як Prometheus, та візуалізуватися за допомогою Grafana.
 Управління
 Інструменти управління API служать шлюзом, який надає послуги, що дозволяють такі можливості:
 -Клієнти API забезпечують себе, отримуючи ключ API
 -Постачальники API налаштовують DNS, кешування, політики регулювання, керування версіями API, канарування.
 -Ці функції та багато іншого доступні на шлюзі API AWS. 
 2.	п
 2.2.	Опис системи та тестування
 	Оскільки проект не є надто великим і можливо буде в майбутньому масштабуватись то було вирішено обрати платформу Node.js з використанням фреймворку Express.js для створення роутінгу.
 Також для зручності було обрано NoSQL базу даних – MongoDB, з використання ORM бібліотеки Mongoose також використовували глобальне хмарне сховище MongoDB Atlas. Оскільки як і MongoDB так і Node.js не є затратними і дорогими технологіями, тому їх легко підтримувати в майбутньому.
 Для коректної аутентифікації було обрано використовувати JSON Web Tokens, для захищеності ресурсів, за допомогою перевірки прав користувача на доступ до певних даних.
 Для тестування обрали Postman.
 Використовували також систему контролю версій Git для збереження всіх версій програми.

 Спочатку було вирішено спроектувати грамотну і коректну базу даних:

 	Рис 1. База даних
 	Після того було створено систему роутінгу з коректними шляхами та обробкою помилок, щоб програма не «падала» через якусь неправильну дію.



 Рис 2. Роути(шляхи) створені за допомогою Express.js

 Наступник кроком було створення функцій:
 •	getLessons() – отримати розклад всіх уроків,
 •	getLesson() – отримати розклад одного уроку,
 •	postCreateLesson() – створення нового уроку(має права тільки вчитель),
 •	postEditLesson()  - зміна уроку(має права тільки вчитель),
 •	postDeleteLesson() – видалення уроку(має права тільки вчитель).
 Звичайно за допомогою аутентифікації не кожен користувач мав права на деякі дії.
 Далі був процес тестування за допомогою Postman. Де було знайдено декілька помилок, а саме некоректність роботи роутів та обробки помилок, це все ми успішно виправили.


 ВИСНОВОК

 В даній роботі було виконано групове завдання, а саме розроблено робочий back-end на базі архітектурного підходу REST API, було опановано на практиці технології, методології, процеси тестування ПЗ. Я навчилась працювати з найпопулярнішими і найпотужнішими фреймворками і платформами, отримала теоретичний і практичний  досвід роботи з збереження та захисту інформації та тестування програм.
 І варто також вказати, що не менш важливим, окрім нових знань та вмінь, була можливість попрацювати в команді та отримати досвід командної розробки.

  
 СПИСОК ВИКОРИСТАНОЇ ЛІТЕРАТУРИ
 1.	https://medium.com/@andr.ivas12/rest78h
 2.	https://habr.com/ru/post/483202/
 3.	https://ru.wikipedia.org/wiki/REST
 4.	https://www.linkedin.com/learning/http-essential-training
 5.	https://www.linkedin.com/learning/learning-rest-apis


ЗВІТ
з проектно-технологічної практики
на тему
“ Дослідження та створення архітектурного стилю REST API ”



Виконав:
студент групи КІ – 41
Коваленко Ю.А.
Перевірив
Мороз І. В.
Оцінка:


Львів – 2020

ЗМІСТ
ВСТУП	3
1.	ТЕОРЕТИЧНІ ВІДОМОСТІ	4
1.1.	Опис бази практики	4
1.2.	Основні відомості про REST API	6
1.3.	Переваги використання REST API.	12
1.4.	Коли вигідне застосування архітектурного стилю REST API	14
2.	ПРАКТИНА ЧАСТИНА	15
2.1.	Технології для створення архітектурного стилю REST API	15
2.2.	Опис системи та тестування	24
СПИСОК ВИКОРИСТАНОЇ ЛІТЕРАТУРИ	27


 
ВСТУП
REST однин з найпопулярніших архітуктурних підходів
REST на сьогоднішній день практично витіснив всі інші підходи, в тому числі дизайн заснований на SOAP і WSDL.
Rеpresentational State Transfer - це архітектура, тобто принципи побудови розподілених гіпермедіа систем, того що іншими словами називається World Wide Web, включаючи універсальні способи обробки і передачі станів ресурсів по HTTP
 
1.	ТЕОРЕТИЧНІ ВІДОМОСТІ
1.1.	Опис бази практики
Базою практики було обрано та одобрено ФОП Олішинського Ярослава Борисовича.
На базі практики мала змогу отимати досвід з таких галузей як «Комп'ютерне програмування» та «Консультування з питань інформатизації»

Навчальний проект
Базою практики було вирішено дати мені змогу отримати практичні навички і навчитись на практиці працювати з одним з найпопулярніших архітектурних підходів таких як REST, використовуючи сучасні та популярні технології.
Реалізувати REST API на express.js, яка буде імітувати роботу простої моделі “School” із CRUD операціями. Наприклад, повинні бути реалізовані роути на створення, читання (всіх та по ід), редагування та видалення уроку (заняття, лекції, пари тощо), кожен із яких має:
•	Тему
•	Вчителя (лектора) (зв’язок з окремою колекцією(таблицею))
•	Група учнів (студентів) (зв’язок з окремою колекцією(таблицею), студент - також окрема колекція(таблиця))
•	Кабінет (клас, аудиторію)
•	Час старту та кінця (або ж порядковий номер уроку/пари із заданого розкладу)

Основні вимоги до проекту:
1. робочий бекенд проект
2. логічно спроектована REST API і база даних
3. демонстрація роботи з гітом

Основні інструменти для виконання завдання.
Під час практики я використвувала:
•	Ноутбук ASUS
•	WebStorm – середовище для розробки
•	Postman – засіб тестування
•	Google Chrome/DevTools – засоби тестування, запуску та відлагодження.
•	Git –система контролю версій
•	SCRUM – методологія робочого процесу

 

1.2.	Основні відомості про REST API
REpresentational State Transfer - це архітектура, тобто принципи побудови розподілених гіпермедіа систем, того що іншими словами називається World Wide Web, включаючи універсальні способи обробки і передачі станів ресурсів по HTTP
Автор ідеї та терміну Рой Філдінг 2000р.
REST на сьогоднішній день практично витіснив всі інші підходи, в тому числі дизайн заснований на SOAP і WSDL
Що нам дає REST підхід
Масштабованості взаємодії компонентів системи (додатки)
спільність інтерфейсів
Незалежне впровадження компонентів
Проміжні компоненти, що знижують затримку, які посилюють безпеку
	Що таке RESTful:
Щоб розподілена система вважалася сконструйованої по REST архітектурі (Restful), необхідно, щоб вона задовольняла таким критеріям:
Client-Server. Система повинна бути розділена на клієнтів і на серверів. Поділ інтерфейсів означає, що, наприклад, клієнти не пов'язані зі зберіганням даних, яке залишається всередині кожного сервера, так що мобільність коду клієнта поліпшується. Сервери не пов'язані з інтерфейсом користувача або станом, так що сервери можуть бути простіше і масштабуються. Сервери та клієнти можуть бути замінні і розроблятися незалежно, поки інтерфейс не змінюється.
Stateless. Сервер не повинен зберігати будь-якої інформації про клієнтів. У запиті повинна зберігатися вся необхідна інформація для обробки запиту і якщо необхідно, ідентифікації клієнта.
Cache. Кожна відповідь повинна бути зазначена чи є він кешувального чи ні, для запобігання повторного використання клієнтами застарілих або некоректних даних у відповідь на подальші запити.
Uniform Interface. Єдиний інтерфейс визначає інтерфейс між клієнтами і серверами. Це спрощує і відокремлює архітектуру, яка дозволяє кожній частині розвиватися самостійно.
Чотири принципи єдиного інтерфейсу:
Identification of resources (заснований на ресурсах). У REST ресурсом є все те, чого можна дати ім'я. Наприклад, користувач, зображення, предмет (майка, голодна собака, поточна погода) і т.д. Кожен ресурс в REST повинен бути ідентифікований за допомогою стабільного ідентифікатора, який не змінюється при зміні стану ресурсу. Ідентифікатором в REST є URI.
Manipulation of resources through representations. (Маніпуляції над ресурсами через подання). Подання в REST використовується для виконання дій над ресурсами. Подання ресурсу являє собою поточний або бажаний стан ресурсу. Наприклад, якщо ресурсом є користувач, то поданням може бути XML або HTML опис цього користувача.
Self-descriptive messages (само-документовані повідомлення). Під само-описовістю мається на увазі, що запит і відповідь повинні зберігати в собі всю необхідну інформацію для їх обробки. Чи не повинні бути додаткові повідомлення чи кеші для обробки одного запиту. Іншими словами відсутність стану, що зберігається між запитами до ресурсів. Це дуже важливо для масштабування системи.
HATEOAS (hypermedia as the engine of application state). Статус ресурсу передається через вміст body, параметри рядка запиту, заголовки запитів і запитуваний URI (ім'я ресурсу). Це називається гіпермедіа (або гіперпосилання з гіпертекстом). HATEOAS також означає, що, в разі необхідності посилання можуть містяться в тілі відповіді (або заголовках) для підтримки URI, вилучення самого об'єкта або запитаних об'єктів.
5 .Layered System. У REST допускається розділити систему на ієрархію шарів але з умовою, що кожен компонент може бачити компоненти тільки безпосередньо наступного шару. Наприклад, якщо ви викликайте службу PayPal а він в свою чергу викликає службу Visa, ви про виробу та техніки безпеки Visa нічого не повинні знати.
6. Code-On-Demand (опціонально). У REST дозволяється завантаження і виконання коду або програми на стороні клієнта.
Сервери можуть тимчасово розширювати або кастомизировать функціонал клієнта, передаючи йому логіку, яку він може виконувати. Наприклад, це можуть бути скомпільовані Java-аплети або клієнтські скрипти на Javascript


Ідемпотентність
З точки зору RESTful-сервісу, операція (або виклик сервісу) ідемпотентна тоді, коли клієнти можуть робити один і той же виклик неодноразово при одному і тому ж результаті на сервері. Іншими словами, створення великої кількості ідентичних запитів має такий же ефект, як і один запит. Зауважте, що в той час, як ідемпотентна операції виробляють один і той же результат на сервері, відповідь сам по собі може не бути тим же самим (наприклад, стан ресурсу може змінитися між запитами).
Методи PUT і DELETE за визначенням ідемпотентна. Проте, є один нюанс з методом DELETE. Проблема в тому, що успішний DELETE-запит повертає статус 200 (OK) або 204 (No Content), але для подальших запитів буде весь час повертати 404 (Not Found), Стан на сервері після кожного виклику DELETE те ж саме, але відповіді різні .
Методи GET, HEAD, OPTIONS і TRACE визначені як безпечні. Це означає, що вони призначені тільки для отримання інформації та не повинні змінювати стан сервера. Вони не повинні мати побічних ефектів, за винятком нешкідливих ефектів, таких як: логирование, кешування, показ банерної реклами або збільшення веб-лічильника.
За визначенням, безпечні операції ідемпотентна, так як вони призводять до одного і того ж результату на сервері. Безпечні методи реалізовані як операції тільки для читання. Однак безпека не означає, що сервер повинен повертати той же самий результат кожного разу.
HTTP методи для створення RESTful сервісів
HTTP метод GET використовується для отримання (або читання) уявлення ресурсу. У разі "вдалого" (або не містять помилок) адреси, GET повертається уявлення ресурсу у форматі XML або JSON в поєднанні з кодом стану HTTP 200 (OK). У разі наявності помилок зазвичай повертається код 404 (NOT FOUND) або 400 (BAD REQUEST).
GET http://www.example.com/api/v1.0/users (повернути список користувачів)
GET http://www.example.com/api/v1.0/users/12345 (повернути дані про користувача з id 12345)
GET http://www.example.com/api/v1.0/users/12345/orders
HTTP метод PUT зазвичай використовується для надання можливості поновлення ресурсу. Тіло запиту при відправленні PUT-запиту до існуючого ресурсу URI має містити оновлені дані оригінального ресурсу (повністю, або тільки оновлювану частина).
Для створення нових екземплярів ресурсу переважніше використання POST запиту. В даному випадку, при створенні екземпляра буде надано коректний ідентифікатор екземпляра ресурсу в повернутих даних про екземпляр.
При успішному оновленні за допомогою виконання PUT запиту повертається код 200 (або 204 якщо не був переданий будь-якої контент в тілі відповіді). PUT небезпечно операція, так як внаслідок її виконання відбувається модифікація (або створення) примірників ресурсу на стороні сервера, але цей метод ідемпотентів. Іншими словами, створення або оновлення ресурсу за допомогою відправки PUT запиту - ресурс не зникне, буде розташовуватися там же, де і був при першому зверненні, а також, багаторазове виконання одного і того ж PUT запиту не змінить загального стану системи
PUT http://www.example.com/api/v1.0/users/12345 (оновити дані користувача з id 12345)
PUT http://www.example.com/api/v1.0/users/12345/orders/98765 (оновити дані замовлення з id 98765 для користувача з id 12345)
HTTP метод POST запит найбільш часто використовується для створення нових ресурсів. На практиці він використовується для створення вкладених ресурсів. Іншими словами, при створенні нового ресурсу, POST запит відправляється до батьківського ресурсу і, таким чином, сервіс бере на себе відповідальність на встановлення зв'язку створюваного ресурсу з батьківським ресурсом, призначення нового ресурсу ID і т.п.
При успішному створенні ресурсу повертається HTTP код 201, а також в заголовку `Location` передається адреса створеного ресурсу.
POST не є безпечним або ідемпотентна запитом. Тому рекомендується його використання для НЕ ідемпотентна запитів. В результаті виконання ідентичних POST запитів надаються сильно схожі, але не ідентичні дані.
POST http://www.example.com/api/v1.0/customers (створити новий ресурс в розділі customers)
POST http://www.example.com/api/v1.0/customers/12345/orders (створити замовлення для ресурсу з id 12345)
HTTP метод DELETE використовується для видалення ресурсу, ідентифікованого конкретним URI (ID).
При успішному видаленні повертається 200 (OK) код HTTP, спільно з тілом відповіді, що містить дані віддаленого ресурсу. Також можливе використання HTTP коду 204 (NO CONTENT) без тіла відповіді. Згідно зі специфікацією HTTP, DELETE запит ідемпотентів. Якщо ви виконуєте DELETE запит до ресурсу, він видаляється. Повторний DELETE запит до ресурсу закінчиться також: ресурс видалений. Якщо DELETE запит використовується для декремента лічильника, DELETE запит не є ідемпотентна. Використовуйте POST для НЕ ідемпотентна операцій.
Проте, існує застереження про ідемпотентності DELETE. Повторний DELETE запит до ресурсу часто супроводжується 404 (NOT FOUND) кодом HTTP через те, що ресурс вже видалений (наприклад з бази даних) і більш не доступний. Це робить DELETE операція не Ідемпотентний, але це загальноприйнятий компроміс на той випадок, якщо ресурс був вилучений з бази даних, а не позначений, як віддалений.
DELETE http://www.example.com/api/v1.0/customers/12345 (видалити з customers ресурс з id 12345)
DELETE http://www.example.com/api/v1.0/customers/12345/orders/21 (видалити у ресурсу з id 12345 замовлення з id 21)
Коди станів HTTP
Основні групи кодів станів: (link)

1xx: Information
100: Continue
2xx: Success
200: OK
201: Created
202: Accepted
204: No Content
3xx: Redirect
301: Moved Permanently
307: Temporary Redirect
4xx: Client Error
400: Bad Request
401: Unauthorized
403: Forbidden
404: Not Found
5xx: Server Error
500: Internal Server Error
501: Not Implemented
502: Bad Gateway
503: Service Unavailable
504: Gateway Timeout


1.3.	Переваги використання REST API.
Переваги REST:
Відсутність додаткових внутрішніх прошарків, що означає передачу даних в тому ж вигляді, що і самі дані. Тобто дані не обертаються в XML, як це робить SOAP і XML-RPC, не використовується AMF, як це робить Flash і т.д. Просто віддаються самі дані.
Кожна одиниця інформації (ресурс) однозначно визначається URL - це значить, що URL по суті є первинним ключем для одиниці даних. Причому абсолютно не має значення, в якому форматі знаходяться дані за адресою - це може бути і HTML, і jpeg, і документ Microsoft Word.
Як відбувається управління інформацією ресурсу - це цілком і повністю ґрунтується на протоколі передачі даних. Найбільш поширений протокол звичайно ж HTTP. Для HTTP дію над даними задається за допомогою методів: GET (отримати), PUT (додати, замінити), POST (додати, змінити, видалити), DELETE (видалити). Таким чином, дії CRUD (Create-Read-Update-Delete) можуть виконуватися як з усіма 4-ма методами, так і тільки за допомогою GET і POST.

 
1.4.	Коли вигідне застосування архітектурного стилю REST API
Коли використовувати REST?
• Коли є обмеження пропускної здатності з'єднання
• Якщо необхідно кешувати запити
• Якщо система передбачає значне масштабування
• У сервісах, що використовують AJAX
 
2.	ПРАКТИНА ЧАСТИНА
2.1.	Технології для створення архітектурного стилю REST API
Як відомо мова програмування всього лиш інструмент, тому щоб написати повноцінний REST API можна вибрати будь яку технологію для так званого роутингу. Однак варто зазначити, що кожна з цих технологій вибирається відповідно до певних вимог, таких як об’єм проекту, його вартість, складність операцій, і тд.
Найпопулярніші з них:
1.	Java/Spring
2.	.NET\C#
3.	Node.js/Express
4.	Python
Важливо також не забути про бази даних, адже навіть наймінімальніший сервіс використвоє їх. Існує як SQL так і NoSQL бази даних і кожна з них вибирається відповідно до технології і мови програмування, а також відповідно до вимог які та об’єму даних, які буде використовувати сервіс.
Найпопулярніші БД:
1.	MySQL
2.	PostgreSQL
3.	MongoDB
4.	Redis
Крім БД також часто застосовуються ORM бібліотеки для спрощення операцій доступу до БД.(Sequelize, Mongoose, та інші)
Також важливою складовою є саме захист даних від зловмисників, одними з найпопулярніших способів є використання JWT-auth, Passport.js, bcrypt.js.
Розробка REST API
1.
Цей набір інструментів, необхідних для побудови REST API. Ці інструменти не залежать від платформи, а це означає, що вони застосовні до REST API, побудованих з будь-яким стеком технологій.
Детальний виклад цих інструментів можна знайти в Інтернеті. Різні етапи розробки API перелічені нижче.
Дизайн - Основною метою тут є визначення форми API, інтерфейсів документів та надання кінцевих точок заглушки.
Тестування -  Тут ми виконуємо функціональне тестування API, надсилаючи запит та аналізуючи відповідь на різних рівнях видимості, а саме: додаток, HTTP та мережа.
Веб-хостинг -  при розгортанні в Інтернеті існують HTTP-інструменти, які допомагають розміщувати API для продуктивності, безпеки та надійності.
Продуктивність -  Перш ніж переходити до виробництва, ми використовуємо інструменти для тестування продуктивності API, які повідомляють нам, скільки навантажень можуть підтримувати API.
Спостережливість -  Після того, як API розгорнуто у виробництві, тестування у виробництві забезпечує загальний стан активних API та попереджає нас, якщо виникає проблема.
Управління -  нарешті, ми розглянемо деякі інструменти для діяльності з управління API, такі як формування трафіку, синьо-зелене розгортання, канарейка тощо.
На наступному малюнку показано різні етапи висвітлення інструментів.
Дизайн
На етапі проектування розробник API співпрацює з клієнтами API та постачальником даних, щоб отримати форму API. REST API по суті складається з обміну повідомленнями JSON через HTTP. JSON є домінуючим форматом в REST API, оскільки він компактний, простий у розумінні та має гнучкий формат, який не вимагає попереднього декларування схеми. Різні клієнти можуть використовувати один і той же API і читати потрібні їм дані.
Swagger- це інструмент, який використовує відкритий формат для опису API у поєднанні з веб-інтерфейсом для візуалізації та спільного використання. Не існує поділу між дизайном та реалізацією. Це інструмент документації API, де документація розміщується поряд з API. Перевага цього полягає в тому, що API та документація також залишатимуться синхронізованими. Недоліком є те, що лише розробники API можуть змінювати структуру API. Документація формується з API. Це означає, що нам потрібно спочатку побудувати скелет нашого API. Ми використали Spring Boot для розробки API та пакету Springfox для створення документації про перевід.
Тестування
Функціональне тестування API REST передбачає надсилання запитів HTTP та перевірку відповідей, щоб ми могли перевірити, чи працюють API, як ми очікуємо. REST використовує HTTP для транспортування, що визначає формати запитів та відповідей API. TCP / IP, у свою чергу, приймає повідомлення HTTP і вирішує, як їх транспортувати по дроту.
Postman - це клієнт REST, який дозволяє нам тестувати API REST. Це дозволяє нам:
Створювати HTTP-запити та генерувати еквівалентні команди cURL, які можна використовувати у сценаріях.
Створювати кілька середовищ для Dev, Test, Pre-Prod, оскільки кожне середовище має різні конфігурації.
Створювати колекцію тестів, що містить кілька тестів для кожної галузі продукту. Різні частини тесту можна параметризувати, що дозволяє нам перемикатися між середовищами.
Створювати фрагменти коду в JavaScript, щоб збільшити наші тести, наприклад, затвердити коди повернення або встановити змінні середовища.
Автоматизовувати запуск тестів за допомогою інструменту командного рядка під назвою Newman.
Веб хостинг
Розглянемо деякі функції протоколу HTTP, які при правильному використанні допомагають нам забезпечити ефективні, високодоступні, надійні та безпечні API. Зокрема, ми розглянемо три частини протоколу HTTP - кешування для продуктивності, DNS для високої доступності та масштабованості та TLS для транспортної безпеки.
Кешування -  кешування - це один із найкращих способів поліпшити роботу клієнта та зменшити навантаження на API. HTTP дозволяє клієнтам зберігати копію ресурсу локально, надсилаючи у відповідь заголовок кешування. Наступного разу клієнт надсилає HTTP-запит на той самий ресурс, він буде обслуговуватися з локального кешу. Це економить як мережевий трафік, так і обчислювальне навантаження на API.
HTTP 1.0 Кешування закінчення терміну дії . HTTP 1.0 забезпечує Expiresзаголовок у відповіді HTTP із зазначенням часу, коли ресурс закінчується. Це може бути корисно для спільного ресурсу з фіксованим часом закінчення.
HTTP 1.1 Кешування закінчення терміну дії . HTTP 1.1 забезпечує більш гнучкий заголовок закінчення терміну дії, cache-controlякий вказує клієнту кешувати ресурс протягом періоду, який встановлений у max-ageзначенні. Існує ще одне значення, s-maxageяке можна встановити для посередників, наприклад, кеш-проксі.
Кешування HTTP-перевірки . При кешуванні виникає проблема, коли клієнт має застарілий ресурс або два клієнти мають різні версії одного ресурсу. Якщо це неприйнятно або якщо є персоналізовані ресурси, які неможливо кешувати, наприклад, маркери автентифікації, HTTP забезпечує кешування перевірки. За допомогою кешування перевірки HTTP надає заголовки у відповіді Etagабо last-modifiedмітці часу. Якщо API повертає будь-який із двох заголовків, клієнти кешують його та включають у наступні виклики GET до API.
Якщо ресурс не змінено, API поверне 304 Not Modifiedвідповідь без тіла, і клієнт може безпечно використовувати його кешовану копію.
DNS -  Система доменних імен знаходить IP-адреси для доменного імені, щоб клієнти могли направити свій запит на правильний сервер. Коли HTTP-запит зроблений, клієнти спочатку запитують DNS-сервер, щоб знайти адресу для хоста, а потім відправляють запит безпосередньо на IP-адресу. DNS - це багаторівнева система, яка сильно кешована, щоб гарантувати, що запити не сповільнюються. Клієнти підтримують DNS-кеш, тоді є проміжні DNS-сервери, що ведуть аж до сервера імен. DNS забезпечує CNAME (Canonical Names) для доступу до різних частин сервера, наприклад, і API, і веб-сервер можуть розміщуватися на одному сервері з двома різними CNAME - api.endpoint.comіwww.endpoint.comабо CNAME можуть вказувати на різні сервери. CNAME також дозволяють нам відокремлювати частини нашого API. Для HTTP-запитів GET ми можемо мати окремий CNAME для статичних та транзакційних ресурсів, що дозволяє нам встановити проксі-сервер для ресурсів, які, як ми знаємо, можуть бути зверненнями в кеш. Ми також можемо мати CNAME для запитів HTTP POST для розділення читання та запису, щоб ми могли масштабувати їх самостійно. Або ми можемо забезпечити швидкісний шлях для пріоритетних клієнтів.
З розширеними DNS, такими як Route53, один CNAME замість того, щоб просто вказувати на один сервер, може вказувати на кілька серверів. Потім політика маршрутизації може бути налаштована на зважену маршрутизацію, маршрутизацію із затримкою або на відмовостійкість.

TLS -  Ми можемо захистити наші API за допомогою TLS, що дозволяє нам обслуговувати наш запит через HTTPS. HTTPS працює за основним принципом безпеки пари ключів. Щоб увімкнути HTTPS на нашому API, нам потрібен сертифікат на нашому сервері, який містить відкриту та приватну пару ключів. Сервер надсилає відкритий ключ клієнту, який використовує його для шифрування даних, а сервер використовує свій приватний ключ для їх розшифровки. Коли клієнт вперше підключається до кінцевої точки HTTPS, відбувається рукостискання, коли клієнт і сервер домовляються про те, як шифрувати трафік. Вони обмінюються ще одним унікальним для сеансу ключем, який використовується для шифрування та дешифрування даних протягом усього сеансу. Під час початкового рукостискання відбувається атрибут продуктивності через асиметричне шифрування, але після встановлення зв’язку використовується симетричне шифрування, яке відбувається досить швидко.
Для проксі-серверів для кешування трафіку TLS нам потрібно завантажити той самий сертифікат, який використовується для шифрування трафіку. Проксі повинен мати можливість розшифрувати трафік, зберегти його в кеш-пам’яті та зашифрувати тим самим сертифікатом і надіслати клієнту. Деякі проксі-сервери цього не дозволяють. У таких ситуаціях одним із рішень є наявність двох CNAME - один для статичних кешуваних ресурсів через HTTP та для персоналізованих ресурсів, що не кешуються, запити через захищений канал TLS будуть обслуговуватися API безпосередньо.
Продуктивність
Розглянемо інструменти для тестування нашого API, щоб ми могли кількісно визначити, з яким обсягом трафіку може впоратися наша інфраструктура. Основна ідея тестування продуктивності полягає в тому, щоб одночасно надсилати до API багато запитів і бачити, в який момент продуктивність погіршується і в кінцевому підсумку не вдається. Відповіді, які ми шукаємо, такі:
Який час відгуку може дати API за різних умов навантаження?
Скільки одночасних запитів API може обробляти без помилок?
Яка інфраструктура потрібна для досягнення бажаної продуктивності?
loader.io - це хмарна послуга безкоштовного тестування навантаження, яка дозволяє стрес-тестувати наші API. Для отримання базової продуктивності API можна проводити різні види навантажувальних тестів із збільшенням навантажень, що вимірюється кількістю запитів в секунду, щоб дізнатися показники продуктивності, кількісно виражені помилками та часом відгуку, для
Тест на замочування -  середнє навантаження протягом тривалих періодів, наприклад, біг протягом 48 годин при 1 запиті в секунду. Це дозволить виявити будь-які витоки пам’яті чи інші подібні приховані помилки.
Тест навантаження -  пікове навантаження, наприклад, виконуйте 2K запити в секунду за допомогою 6 екземплярів API.
Стрес-тест -  перевищення пікового навантаження, наприклад, 10 000 запитів в секунду протягом 10 хвилин.
Це також дозволяє нам визначитись з інфраструктурою, яка дозволить нам поставляти API із бажаними показниками продуктивності та чи масштабується наше рішення лінійно.
Спостережливість
Як тільки API розгортається у виробництві, це не означає, що ми можемо забути про API. Розгортання виробництва розпочинає черговий етап тестування - тестування у виробництві, яке може виявити проблеми, які залишались невловимими на попередніх етапах. Випробування на виробництві включають комплекс заходів, об'єднаних як спостережливість, що включає реєстрацію, моніторинг та відстеження. Інструменти для цієї діяльності допоможуть нам діагностувати та вирішувати проблеми, виявлені у виробництві.
Протоколювання -  реєстрація повинна виконуватися розробниками явно, використовуючи бажану структуру ведення журналу та стандарт ведення журналу. Наприклад, один оператор журналу на кожні 10 рядків коду або більше, якщо код складний з рівнями журналу, розділеними на - 60 відсотків DEBUG, 25 відсотків INFO, 10 відсотків ПОПЕРЕДЖЕННЯ і 5 відсотків ПОМИЛКИ.
Моніторинг -  Моніторинг працює на вищому рівні, ніж реєстрація. Хоча реєстрація явно повідомляє нам, що відбувається з API, моніторинг забезпечує загальний стан роботи API, використовуючи загальні показники, виставлені платформою та самим API. Зазвичай показники виставляються агентом, розгорнутим на сервері, або він може бути частиною рішення, і періодично збирається рішенням моніторингу, розгорнутим віддалено.
Діагностичні кінцеві точки можуть бути включені в рішення, яке повідомляє нам про загальний стан роботи API.
Zipkin - це розподілена система трасування. Це допомагає зібрати дані про терміни, необхідні для усунення проблем із затримками в архітектурі мікросервісу.
Увімкнення централізованого журналювання охоплює ведення журналу та трасування. Для моніторингу цікаві показники можуть зберігатися в магазині часових рядів, таких як Prometheus, та візуалізуватися за допомогою Grafana.
Управління
Інструменти управління API служать шлюзом, який надає послуги, що дозволяють такі можливості:
-Клієнти API забезпечують себе, отримуючи ключ API
-Постачальники API налаштовують DNS, кешування, політики регулювання, керування версіями API, канарування.
-Ці функції та багато іншого доступні на шлюзі API AWS. 
2.	п
2.2.	Опис системи та тестування
	Оскільки проект не є надто великим і можливо буде в майбутньому масштабуватись то було вирішено обрати платформу Node.js з використанням фреймворку Express.js для створення роутінгу.
Також для зручності було обрано NoSQL базу даних – MongoDB, з використання ORM бібліотеки Mongoose також використовували глобальне хмарне сховище MongoDB Atlas. Оскільки як і MongoDB так і Node.js не є затратними і дорогими технологіями, тому їх легко підтримувати в майбутньому.
Для коректної аутентифікації було обрано використовувати JSON Web Tokens, для захищеності ресурсів, за допомогою перевірки прав користувача на доступ до певних даних.
Для тестування обрали Postman.
Використовували також систему контролю версій Git для збереження всіх версій програми.

Спочатку було вирішено спроектувати грамотну і коректну базу даних:

	Рис 1. База даних
	Після того було створено систему роутінгу з коректними шляхами та обробкою помилок, щоб програма не «падала» через якусь неправильну дію.



Рис 2. Роути(шляхи) створені за допомогою Express.js

Наступник кроком було створення функцій:
•	getLessons() – отримати розклад всіх уроків,
•	getLesson() – отримати розклад одного уроку,
•	postCreateLesson() – створення нового уроку(має права тільки вчитель),
•	postEditLesson()  - зміна уроку(має права тільки вчитель),
•	postDeleteLesson() – видалення уроку(має права тільки вчитель).
Звичайно за допомогою аутентифікації не кожен користувач мав права на деякі дії.
Далі був процес тестування за допомогою Postman. Де було знайдено декілька помилок, а саме некоректність роботи роутів та обробки помилок, це все ми успішно виправили.


ВИСНОВОК

В даній роботі було виконано групове завдання, а саме розроблено робочий back-end на базі архітектурного підходу REST API, було опановано на практиці технології, методології, процеси тестування ПЗ. Я навчилась працювати з найпопулярнішими і найпотужнішими фреймворками і платформами, отримала теоретичний і практичний  досвід роботи з збереження та захисту інформації та тестування програм.
І варто також вказати, що не менш важливим, окрім нових знань та вмінь, була можливість попрацювати в команді та отримати досвід командної розробки.

 
СПИСОК ВИКОРИСТАНОЇ ЛІТЕРАТУРИ
1.	https://medium.com/@andr.ivas12/rest78h
2.	https://habr.com/ru/post/483202/
3.	https://ru.wikipedia.org/wiki/REST
4.	https://www.linkedin.com/learning/http-essential-training
5.	https://www.linkedin.com/learning/learning-rest-apis
